// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_METRICS_IO_PROMETHEUS_CLIENT_H_
#define FLATBUFFERS_GENERATED_METRICS_IO_PROMETHEUS_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

namespace io {
namespace prometheus {
namespace client {

struct LabelPair;

struct Gauge;

struct Counter;

struct Quantile;

struct Summary;

struct Untyped;

struct Bucket;

struct Histogram;

struct Metric;

struct MetricFamily;

enum MetricType {
  MetricType_COUNTER = 0,
  MetricType_GAUGE = 1,
  MetricType_SUMMARY = 2,
  MetricType_UNTYPED = 3,
  MetricType_HISTOGRAM = 4,
  MetricType_MIN = MetricType_COUNTER,
  MetricType_MAX = MetricType_HISTOGRAM
};

inline MetricType (&EnumValuesMetricType())[5] {
  static MetricType values[] = {MetricType_COUNTER, MetricType_GAUGE,
                                MetricType_SUMMARY, MetricType_UNTYPED,
                                MetricType_HISTOGRAM};
  return values;
}

inline const char **EnumNamesMetricType() {
  static const char *names[] = {"COUNTER", "GAUGE",     "SUMMARY",
                                "UNTYPED", "HISTOGRAM", nullptr};
  return names;
}

inline const char *EnumNameMetricType(MetricType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMetricType()[index];
}

struct LabelPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_NAME = 4, VT_VALUE = 6 };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) && verifier.EndTable();
  }
};

struct LabelPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LabelPair::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(LabelPair::VT_VALUE, value);
  }
  explicit LabelPairBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelPairBuilder &operator=(const LabelPairBuilder &);
  flatbuffers::Offset<LabelPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LabelPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<LabelPair> CreateLabelPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  LabelPairBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LabelPair> CreateLabelPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const char *value = nullptr) {
  return io::prometheus::client::CreateLabelPair(
      _fbb, name ? _fbb.CreateString(name) : 0,
      value ? _fbb.CreateString(value) : 0);
}

struct Gauge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_VALUE = 4 };
  double value() const { return GetField<double>(VT_VALUE, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct GaugeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Gauge::VT_VALUE, value, 0.0);
  }
  explicit GaugeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GaugeBuilder &operator=(const GaugeBuilder &);
  flatbuffers::Offset<Gauge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gauge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gauge> CreateGauge(
    flatbuffers::FlatBufferBuilder &_fbb, double value = 0.0) {
  GaugeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Counter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_VALUE = 4 };
  double value() const { return GetField<double>(VT_VALUE, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct CounterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Counter::VT_VALUE, value, 0.0);
  }
  explicit CounterBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CounterBuilder &operator=(const CounterBuilder &);
  flatbuffers::Offset<Counter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Counter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Counter> CreateCounter(
    flatbuffers::FlatBufferBuilder &_fbb, double value = 0.0) {
  CounterBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Quantile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_QUANTILE = 4, VT_VALUE = 6 };
  double quantile() const { return GetField<double>(VT_QUANTILE, 0.0); }
  double value() const { return GetField<double>(VT_VALUE, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_QUANTILE) &&
           VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct QuantileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quantile(double quantile) {
    fbb_.AddElement<double>(Quantile::VT_QUANTILE, quantile, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Quantile::VT_VALUE, value, 0.0);
  }
  explicit QuantileBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantileBuilder &operator=(const QuantileBuilder &);
  flatbuffers::Offset<Quantile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quantile>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quantile> CreateQuantile(
    flatbuffers::FlatBufferBuilder &_fbb, double quantile = 0.0,
    double value = 0.0) {
  QuantileBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_quantile(quantile);
  return builder_.Finish();
}

struct Summary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_SAMPLE_COUNT = 4, VT_SAMPLE_SUM = 6, VT_QUANTILE = 8 };
  int64_t sample_count() const { return GetField<int64_t>(VT_SAMPLE_COUNT, 0); }
  double sample_sum() const { return GetField<double>(VT_SAMPLE_SUM, 0.0); }
  const flatbuffers::Vector<flatbuffers::Offset<Quantile>> *quantile() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<Quantile>> *>(
        VT_QUANTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SAMPLE_COUNT) &&
           VerifyField<double>(verifier, VT_SAMPLE_SUM) &&
           VerifyOffset(verifier, VT_QUANTILE) && verifier.Verify(quantile()) &&
           verifier.VerifyVectorOfTables(quantile()) && verifier.EndTable();
  }
};

struct SummaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sample_count(int64_t sample_count) {
    fbb_.AddElement<int64_t>(Summary::VT_SAMPLE_COUNT, sample_count, 0);
  }
  void add_sample_sum(double sample_sum) {
    fbb_.AddElement<double>(Summary::VT_SAMPLE_SUM, sample_sum, 0.0);
  }
  void add_quantile(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Quantile>>>
          quantile) {
    fbb_.AddOffset(Summary::VT_QUANTILE, quantile);
  }
  explicit SummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummaryBuilder &operator=(const SummaryBuilder &);
  flatbuffers::Offset<Summary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Summary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Summary> CreateSummary(
    flatbuffers::FlatBufferBuilder &_fbb, int64_t sample_count = 0,
    double sample_sum = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Quantile>>>
        quantile = 0) {
  SummaryBuilder builder_(_fbb);
  builder_.add_sample_sum(sample_sum);
  builder_.add_sample_count(sample_count);
  builder_.add_quantile(quantile);
  return builder_.Finish();
}

inline flatbuffers::Offset<Summary> CreateSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb, int64_t sample_count = 0,
    double sample_sum = 0.0,
    const std::vector<flatbuffers::Offset<Quantile>> *quantile = nullptr) {
  return io::prometheus::client::CreateSummary(
      _fbb, sample_count, sample_sum,
      quantile ? _fbb.CreateVector<flatbuffers::Offset<Quantile>>(*quantile)
               : 0);
}

struct Untyped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_VALUE = 4 };
  double value() const { return GetField<double>(VT_VALUE, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct UntypedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Untyped::VT_VALUE, value, 0.0);
  }
  explicit UntypedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UntypedBuilder &operator=(const UntypedBuilder &);
  flatbuffers::Offset<Untyped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Untyped>(end);
    return o;
  }
};

inline flatbuffers::Offset<Untyped> CreateUntyped(
    flatbuffers::FlatBufferBuilder &_fbb, double value = 0.0) {
  UntypedBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Bucket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_CUMULATIVE_COUNT = 4, VT_UPPER_BOUND = 6 };
  uint64_t cumulative_count() const {
    return GetField<uint64_t>(VT_CUMULATIVE_COUNT, 0);
  }
  double upper_bound() const { return GetField<double>(VT_UPPER_BOUND, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CUMULATIVE_COUNT) &&
           VerifyField<double>(verifier, VT_UPPER_BOUND) && verifier.EndTable();
  }
};

struct BucketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cumulative_count(uint64_t cumulative_count) {
    fbb_.AddElement<uint64_t>(Bucket::VT_CUMULATIVE_COUNT, cumulative_count, 0);
  }
  void add_upper_bound(double upper_bound) {
    fbb_.AddElement<double>(Bucket::VT_UPPER_BOUND, upper_bound, 0.0);
  }
  explicit BucketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BucketBuilder &operator=(const BucketBuilder &);
  flatbuffers::Offset<Bucket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bucket>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bucket> CreateBucket(
    flatbuffers::FlatBufferBuilder &_fbb, uint64_t cumulative_count = 0,
    double upper_bound = 0.0) {
  BucketBuilder builder_(_fbb);
  builder_.add_upper_bound(upper_bound);
  builder_.add_cumulative_count(cumulative_count);
  return builder_.Finish();
}

struct Histogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_SAMPLE_COUNT = 4, VT_SAMPLE_SUM = 6, VT_BUCKET = 8 };
  uint64_t sample_count() const {
    return GetField<uint64_t>(VT_SAMPLE_COUNT, 0);
  }
  double sample_sum() const { return GetField<double>(VT_SAMPLE_SUM, 0.0); }
  const flatbuffers::Vector<flatbuffers::Offset<Bucket>> *bucket() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bucket>> *>(
        VT_BUCKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLE_COUNT) &&
           VerifyField<double>(verifier, VT_SAMPLE_SUM) &&
           VerifyOffset(verifier, VT_BUCKET) && verifier.Verify(bucket()) &&
           verifier.VerifyVectorOfTables(bucket()) && verifier.EndTable();
  }
};

struct HistogramBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sample_count(uint64_t sample_count) {
    fbb_.AddElement<uint64_t>(Histogram::VT_SAMPLE_COUNT, sample_count, 0);
  }
  void add_sample_sum(double sample_sum) {
    fbb_.AddElement<double>(Histogram::VT_SAMPLE_SUM, sample_sum, 0.0);
  }
  void add_bucket(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bucket>>>
          bucket) {
    fbb_.AddOffset(Histogram::VT_BUCKET, bucket);
  }
  explicit HistogramBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistogramBuilder &operator=(const HistogramBuilder &);
  flatbuffers::Offset<Histogram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Histogram>(end);
    return o;
  }
};

inline flatbuffers::Offset<Histogram> CreateHistogram(
    flatbuffers::FlatBufferBuilder &_fbb, uint64_t sample_count = 0,
    double sample_sum = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bucket>>>
        bucket = 0) {
  HistogramBuilder builder_(_fbb);
  builder_.add_sample_sum(sample_sum);
  builder_.add_sample_count(sample_count);
  builder_.add_bucket(bucket);
  return builder_.Finish();
}

inline flatbuffers::Offset<Histogram> CreateHistogramDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint64_t sample_count = 0,
    double sample_sum = 0.0,
    const std::vector<flatbuffers::Offset<Bucket>> *bucket = nullptr) {
  return io::prometheus::client::CreateHistogram(
      _fbb, sample_count, sample_sum,
      bucket ? _fbb.CreateVector<flatbuffers::Offset<Bucket>>(*bucket) : 0);
}

struct Metric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LABEL = 4,
    VT_GAUGE = 6,
    VT_COUNTER = 8,
    VT_SUMMARY = 10,
    VT_UNTYPED = 12,
    VT_HISTOGRAM = 14,
    VT_TIMESTAMP_MS = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<LabelPair>> *label() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<LabelPair>> *>(VT_LABEL);
  }
  const Gauge *gauge() const { return GetPointer<const Gauge *>(VT_GAUGE); }
  const Counter *counter() const {
    return GetPointer<const Counter *>(VT_COUNTER);
  }
  const Summary *summary() const {
    return GetPointer<const Summary *>(VT_SUMMARY);
  }
  const Untyped *untyped() const {
    return GetPointer<const Untyped *>(VT_UNTYPED);
  }
  const Histogram *histogram() const {
    return GetPointer<const Histogram *>(VT_HISTOGRAM);
  }
  int64_t timestamp_ms() const { return GetField<int64_t>(VT_TIMESTAMP_MS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_LABEL) &&
           verifier.Verify(label()) && verifier.VerifyVectorOfTables(label()) &&
           VerifyOffset(verifier, VT_GAUGE) && verifier.VerifyTable(gauge()) &&
           VerifyOffset(verifier, VT_COUNTER) &&
           verifier.VerifyTable(counter()) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyTable(summary()) &&
           VerifyOffset(verifier, VT_UNTYPED) &&
           verifier.VerifyTable(untyped()) &&
           VerifyOffset(verifier, VT_HISTOGRAM) &&
           verifier.VerifyTable(histogram()) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP_MS) &&
           verifier.EndTable();
  }
};

struct MetricBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LabelPair>>>
          label) {
    fbb_.AddOffset(Metric::VT_LABEL, label);
  }
  void add_gauge(flatbuffers::Offset<Gauge> gauge) {
    fbb_.AddOffset(Metric::VT_GAUGE, gauge);
  }
  void add_counter(flatbuffers::Offset<Counter> counter) {
    fbb_.AddOffset(Metric::VT_COUNTER, counter);
  }
  void add_summary(flatbuffers::Offset<Summary> summary) {
    fbb_.AddOffset(Metric::VT_SUMMARY, summary);
  }
  void add_untyped(flatbuffers::Offset<Untyped> untyped) {
    fbb_.AddOffset(Metric::VT_UNTYPED, untyped);
  }
  void add_histogram(flatbuffers::Offset<Histogram> histogram) {
    fbb_.AddOffset(Metric::VT_HISTOGRAM, histogram);
  }
  void add_timestamp_ms(int64_t timestamp_ms) {
    fbb_.AddElement<int64_t>(Metric::VT_TIMESTAMP_MS, timestamp_ms, 0);
  }
  explicit MetricBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetricBuilder &operator=(const MetricBuilder &);
  flatbuffers::Offset<Metric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metric>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metric> CreateMetric(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LabelPair>>>
        label = 0,
    flatbuffers::Offset<Gauge> gauge = 0,
    flatbuffers::Offset<Counter> counter = 0,
    flatbuffers::Offset<Summary> summary = 0,
    flatbuffers::Offset<Untyped> untyped = 0,
    flatbuffers::Offset<Histogram> histogram = 0, int64_t timestamp_ms = 0) {
  MetricBuilder builder_(_fbb);
  builder_.add_timestamp_ms(timestamp_ms);
  builder_.add_histogram(histogram);
  builder_.add_untyped(untyped);
  builder_.add_summary(summary);
  builder_.add_counter(counter);
  builder_.add_gauge(gauge);
  builder_.add_label(label);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metric> CreateMetricDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LabelPair>> *label = nullptr,
    flatbuffers::Offset<Gauge> gauge = 0,
    flatbuffers::Offset<Counter> counter = 0,
    flatbuffers::Offset<Summary> summary = 0,
    flatbuffers::Offset<Untyped> untyped = 0,
    flatbuffers::Offset<Histogram> histogram = 0, int64_t timestamp_ms = 0) {
  return io::prometheus::client::CreateMetric(
      _fbb,
      label ? _fbb.CreateVector<flatbuffers::Offset<LabelPair>>(*label) : 0,
      gauge, counter, summary, untyped, histogram, timestamp_ms);
}

struct MetricFamily FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_NAME = 4, VT_HELP = 6, VT_TYPE = 8, VT_METRIC = 10 };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *help() const {
    return GetPointer<const flatbuffers::String *>(VT_HELP);
  }
  MetricType type() const {
    return static_cast<MetricType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Metric>> *metric() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Metric>> *>(
        VT_METRIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) && VerifyOffset(verifier, VT_HELP) &&
           verifier.Verify(help()) && VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_METRIC) && verifier.Verify(metric()) &&
           verifier.VerifyVectorOfTables(metric()) && verifier.EndTable();
  }
};

struct MetricFamilyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetricFamily::VT_NAME, name);
  }
  void add_help(flatbuffers::Offset<flatbuffers::String> help) {
    fbb_.AddOffset(MetricFamily::VT_HELP, help);
  }
  void add_type(MetricType type) {
    fbb_.AddElement<int8_t>(MetricFamily::VT_TYPE, static_cast<int8_t>(type),
                            0);
  }
  void add_metric(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metric>>>
          metric) {
    fbb_.AddOffset(MetricFamily::VT_METRIC, metric);
  }
  explicit MetricFamilyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetricFamilyBuilder &operator=(const MetricFamilyBuilder &);
  flatbuffers::Offset<MetricFamily> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetricFamily>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetricFamily> CreateMetricFamily(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> help = 0,
    MetricType type = MetricType_COUNTER,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metric>>>
        metric = 0) {
  MetricFamilyBuilder builder_(_fbb);
  builder_.add_metric(metric);
  builder_.add_help(help);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetricFamily> CreateMetricFamilyDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const char *help = nullptr, MetricType type = MetricType_COUNTER,
    const std::vector<flatbuffers::Offset<Metric>> *metric = nullptr) {
  return io::prometheus::client::CreateMetricFamily(
      _fbb, name ? _fbb.CreateString(name) : 0,
      help ? _fbb.CreateString(help) : 0, type,
      metric ? _fbb.CreateVector<flatbuffers::Offset<Metric>>(*metric) : 0);
}

inline const io::prometheus::client::MetricFamily *GetMetricFamily(
    const void *buf) {
  return flatbuffers::GetRoot<io::prometheus::client::MetricFamily>(buf);
}

inline bool VerifyMetricFamilyBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<io::prometheus::client::MetricFamily>(nullptr);
}

inline void FinishMetricFamilyBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<io::prometheus::client::MetricFamily> root) {
  fbb.Finish(root);
}

}  // namespace client
}  // namespace prometheus
}  // namespace io

#endif  // FLATBUFFERS_GENERATED_METRICS_IO_PROMETHEUS_CLIENT_H_
